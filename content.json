{"pages":[{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"},{"title":"关于我","text":"这是我的个人博客，主要用来记录平时学习中的一些笔记，或是自己做的一些小项目的技术总结。","link":"/about/index.html"}],"posts":[{"title":"内核篇2","text":"","link":"/2020/05/09/%E5%86%85%E6%A0%B8%E7%AF%872/"},{"title":"内核篇1","text":"关于驱动驱动为内核中硬件设备管理模块&emsp;&emsp;硬件设备的运行需要驱动代码，裸机开发中驱动代码需要专门写出来。但是在操作系统中，驱动代码嵌入到了内核里。由于每一种硬件设备需要一种驱动，所以说，内核的版本总是在更新之中。 驱动工作在内核态&emsp;&emsp;对于单核的cpu来讲，微观上cpu在某一刻只能运行一条指令。如果运行的代码属于内核，则为内核态；运行的代码属于应用程序，则为用户态。 驱动程运行时具有很高的权限&emsp;&emsp;由于驱动是运行在内核态的，所以她在运行时，具有最高的权限，也就是说可以任意访问读写内存的任何部分。所以说，驱动开发也伴随着很高的风险，一个不慎，就可能导致内核崩溃，出现安全漏洞。 关于应用程序应用程序是整个系统的最终目标&emsp;&emsp;无论是硬件还是内核，最终的目的就是为用户提供使用功能，而这些功能都是由应用程序来提供的。所以说，应用程序是整个操作系统的最终目标。 应用程序不属于内核，而是在内核之上应用程序工作在用户态，是受到限制的。应用程序出现问题一般不会导致内核崩溃。应用程序通过内核定义的API来调用内核工作。关于根文件系统&emsp;&emsp; 根文件系统为操作系统启动提供了很多东西：根目录，进程1。 根文件系统提供根目录根文件系统提供根目录进程1存放在根文件系统中内核启动最后会装在根文件系统","link":"/2020/05/09/%E5%86%85%E6%A0%B8%E7%AF%871/"},{"title":"uboot常用命令","text":"linux命令行界面缓冲机制&emsp;&emsp;uboot的命令的读取采用的是行缓冲的机制。 行缓冲&emsp;&emsp;在命令行界面下，执行行缓冲，就是说，当你向界面输入命令的时候，输入的东西会先进入缓冲区，不会执行，但是当按下回车键之后，所有刚才输入的东西才会整个拿来分析执行。 无缓冲&emsp;&emsp;无缓冲就是每输入一个字符，系统就会分析处理该字符。 全缓冲&emsp;&emsp;全缓冲就是在输入字符后，直到缓冲区满，不然系统一直都不会去处理。 uboot指令的特点有些命令有简化的别名print==printenvset==setenv 有些命令会带参数不带：print/printenv可带不可带：help（不带参数信息不详细，带参数信息详细）必须带参数：set/setenv 命令中的特殊符号&lt;1&gt;uboot中一些特殊的符号有专门的意思，比如说单引号，目的是为了告诉uboot单引号里面的内容是一整块，不是分开的。&lt;2&gt;分号用来将两个命令隔开 有些命令是一个命令族。&emsp;&emsp;好多个命令都是用同一个开头，后面的部分不同，添加的参数参数和功能也不同，比如说movi命令。但是同一命令族的命令在功能上有很大的关联。比如movi命令族主要对（emmc，inand）进行操作。 uboot常用命令print/printenv官方解释如下 1234printenv - print values of all environment variablesprintenv name ... - print value of environment variable 'name' 由上可以看出，print/printenv有两种使用方式&lt;1&gt;print //用来打印出所有的环境变量。&lt;2&gt;print name //打印出特定的环境变量。 set/setenv官方解释如下 1234setenv name value ... - set environment variable 'name' to 'value ...'setenv name - delete environment variable 'name' 由上可以看出set/setenv有两种使用方式：&lt;1&gt;set name value //给名为name的环境变量赋值为value&lt;2&gt;set name //删除环境变量name save/savesave //将改变的环境变量值存储到flash中 题外话：每次系统上电之后，uboot都会将环境变量从flash中加载一份到ddr（内存）中，每次set的时候，都是对ddr中的环境变量进行改变，直到save指令后，ddr中的环境变量才会覆盖原来flash中的环境变量。","link":"/2020/05/06/uboot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"浅谈I2C","text":"原理&emsp;&emsp;I2C是一种工作在低速，短距离情况下用来传输数据的通信接口。她总共就只有两根线，一根为SCK(serial clock串行时钟线)，一根为SDA(serial data串行数据线)。由此不难看出，她是一种串行的，同步的通信方式。至于信号传输的方向，这里着重说一下。对于通信双方，有主（master）从（slave）之分，在一个确定的通信环境下面，一个master可以对应多个slave（在通信环境确定的情况下，master和slave的角色一般是确定的，不太容易更改），从而实现分时分对象的控制。那么问题来了，那么多的slave，master是如何辨别哪个是哪个呢，I2C的解决方案是通过地址来区分，一般情况下，每个slave都有一个7bit的地址，其中高四位是器件类型，由生产方来决定，低四位有硬件逻辑来编程（也就是说当硬件电路确定了之后，那么slave的地址也就确定了）。然后，通信双方就可以按照规定好的协议开始愉快的交流了。 I2C通信协议&emsp;&emsp; 话不多说，直接上图 &emsp;&emsp; 当master想要给slave发送信息时（write mode），通信开始后，先给SDA发送1byte的数据，这一段数据为：高7位slave的地址+0。然后等待对应的slave发送一个应答信号（ACK），当master收到ACK后，就给slave发送1byte的数据，然后slave收到信息了，就再给master发送一个ACK，至此，一个通信周期结束。&emsp;&emsp; 当slave要给master发送数据时（read mode），通信开始后，master先给SDA发送1byte的数据，数据为：高7位的slave地址+1（用1和0来区别到底是都还是写）。然后slave先ACK，然后紧接着就发送过来1byte的数据，发送完之后，等待master的ACK，之后一个通信周期结束。&emsp;&emsp; 各位看官看到这里，是不是对I2C通信协议有了大概的了解呢，但是心里肯定还是有不少疑惑，比如说，数据全部都是通过电平信号来传输的，那么我怎么知道什么情况下通信开始？什么情况下通信结束？是么样的信号算是应答信号？各种信号在时间上又如何调节呢？莫急，我们再上图 &emsp;&emsp; 这前面这两张图片时三星某soc的datasheet上抠下来的，这里做个说明 &emsp;&emsp; 言归正传，大家看到这张图片是不是有点恍恍然的感觉呢，没错，这张时序图可以将我们之前的疑惑一一解除。首先，我们是否还记得最前面说过得I2C是一个同步通信得方式，那么，如何把握节奏就不言而喻了，就是通过时钟信号来调控。当某一个时刻，SCK为高电平时，SDA上出现了一个下降沿，那么意味着，通信开始，要开始搞事情了。然后master二话不说，先丢1byte得数据过去，告诉众slave，该谁了，该干啥了。然后slave如果没挂（通信时有时候从机会莫名奇妙得由于各种奇葩得原因挂掉）的话，就会站出来说一声，在呢（也就是发送一个ACK给master）。那么具体如何实现ACK呢？I2C总线上的数据时1byte1byte传输的，每传输1byte的数据需要8个时钟周期，当1byte数据传输完毕之后，总线会被控制为高电平(总线释放)，当第九个脉冲之前，应答方将之拉低成了低电平，而且在第九个时钟高电平的时候保持低电平则称之为ACK；要是没有反应，继续保持为高电平，则称之为NACK。然后就是数据传输，又是一个字节，然后ACK，之后完事收工，总线在SCL期间恢复到高电平，即完成一个上升沿，一切的一切恢复如初，好像什么都没有发生过。 &emsp;&emsp; 至此，对I2C算是有了一个粗浅的了解。如文章中有不足之处，还望指正。","link":"/2020/05/02/%E6%B5%85%E8%B0%88I2C/"},{"title":"初识uboot","text":"本文学习自朱有鹏老师嵌入式课程，在此标注 起因&emsp;&emsp;以前学习过一些简单得linux系统移植，发现学的太浅了，脱离了开发板就完全应用不起来，所以现在打算深入得学习一下，力求达到无论是给我什么平台，就给他一顿修改代码，编译下载运行得操作系统跑起来。所以现在打算现从uboot入手开始学习。本文旨在对uboot做一个大概的描述。 臆想&emsp;&emsp;linux kernel刚开始是躺在flash中的，系统上电后不能直接运行起来（体大难移）。所以就需要一段程序来帮他将一切东西都打点好，比如将内存初始化，然后将kernel丢到内存中，然后kernel挂着根文件才能运行起来。那么，仅仅从主要功能上来讲，好像这一段程序只需要初始化一些内存，然后再讲kernel加载到内存就行了。实则非也，由于kernel的启动是不唯一的，也就是说给kernel在启动之前赋予不同的参数，那么它启动 结束之后就是不同的样子，还有就是要判断启动的过程是不是出错了？哪里出错了？肯定得将之表现出来以供人参考，故而需要串口等监视工具，所以还需要初始化串口驱动等等等等。这段功能强大的 程序，都快比的上一个小的操作系统了，她也被称之为bootloader。那么uboot又是何许人也，uboot算是bootloader的一种，但是她是开源的，由于被许多人使用，故而被越来越完善，逐渐成为人们最常用的一种bootloader。 uboot主要功能1.可以上电直接启动：由于soc设计不同，uboot要对应得更改START.S来实现这一功能。2.能够内核启动并为其传参：可以在uboot中设置一定得参数，然后放在内存的特定位置，然后等到内核启动得时候，就回去这些特定得位置解析这些参数，从而按照设定去启动。3.提供系统部署能力：人要能借助uboot完成整个系统（uboot，kernel，rootfs）在flash上的烧录下载工作。4.具有一定得硬件驱动能力：比如inand，串口，lcd等等，根据不同得情景要能够实现soc级和板级一些硬件得驱动能力。5.生命周期：uboot是裸机程序。一旦开始就会单纯运行uboot不能同时其他程序。一旦uboot结束运行，就没法再回到uboot。uboot启动内核之后就废了，想要再回到uboot只能重启。","link":"/2020/05/06/%E5%88%9D%E8%AF%86uboot/"},{"title":"记一次51汇编作业","text":"题目&emsp;&emsp;试设计一个n字节的无符号十进制数加法子程序， 其功能为将 R0和R1指出的内部RAM中两个n字节压缩BCD码无符号十进制整数相加，结果存放于被加数单元中。Ｒ0、 Ｒ1分别指向被加数和加数的低位字节， 字节数ｎ存于R2。运算结果：Ｒ0指向和的低位字节，CY为进位位。 分析子程序流程分析如下： 代码1234567891011121314151617181920212223242526272829 ORG 0000H SJMP MAIN ORG 0030H //初始化MAIN: MOV 40H,#72H MOV 41H,#33H MOV 60H,#33H MOV 61H,#44H //赋值 LCALL SUN SJMP WAIT SUN: MOV R0,#40H //求和子程序 MOV R1,#60H MOV R2,#2 MOV A,R2LOOP: JNZ FSUN SJMP ENDDFSUN: MOV A,@R0 ADDC A,@R1 DA A MOV @R0,A INC R0 INC R1 DEC R2 MOV A,R2 SJMP LOOP ENDD: RETWAIT: SJMP WAITEND 测试结果如下","link":"/2020/05/10/%E8%AE%B0%E4%B8%80%E6%AC%A151%E6%B1%87%E7%BC%96%E4%BD%9C%E4%B8%9A/"},{"title":"初识linux内核","text":"到底什么是操作系统？&emsp;&emsp;具象化来讲就是linux，windows，android，ucos等都属于操作系统。操作系统本质上是一个程序，由很多源文件构成，需要编译链接成操作系统程序（vmlinz，zimage）。主要功能是管理计算机硬件，给应用程序提供运行环境。 核心功能内存管理&emsp;&emsp;没有操作系统的话，就需要程序员自己管理内存，万一出现内存复用的情况，很容易造成代码冲突。但是有了操作系统之后，每一次内存的使用，都需要向操作系统申请注册，这样，就会保证内存一般不会冲突。 进程调度功能&emsp;&emsp;操作系统下支持多个应用程序同时运行。这是宏观上的并行和微观上的串行。 硬件设备的管理&emsp;&emsp;没有操作系统时，控制任何硬件都要自己写代码，有了操作系统之后，操作系统自会控制硬件，应用程序不需要考虑硬件的具体细节。操作系统的硬件设备管理模块就是驱动模块。 文件系统&emsp;&emsp;文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成，存储设备要以扇区为单位进行读写。没有一种管理机制的话，程序就要记住哪个扇区里面存了什么东西，显然这是不现实的。而文件系统像是一个书的目录，可以用来管理哪一部分扇区存储了啥。 扩展功能协议栈有用的应用程序包&emsp;&emsp; 应用程序本身不属于操作系统内核，而是可以通过功能需求 进行增减的。 内核和发行版的区别&emsp;&emsp;内核只负责实现操作系统的核心功能，比如：内存管理，进度调控等等等等，应用程序并不包括在内。当一个操作系统基于内核，又包含了许多应用程序包等等面向使用者的接口，就可以称之为操作系统。由于不同产家根据不同的需求基于内核开发出各种内核的操作系统，称之为发行版。 内核只有一个linux内核网址 发行版很多ubuntu，redhat，centos等等。","link":"/2020/05/07/%E5%88%9D%E8%AF%86linux%E5%86%85%E6%A0%B8/"}],"tags":[{"name":"-内核的模块化","slug":"内核的模块化","link":"/tags/%E5%86%85%E6%A0%B8%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"-uboot命令","slug":"uboot命令","link":"/tags/uboot%E5%91%BD%E4%BB%A4/"},{"name":"-I2C","slug":"I2C","link":"/tags/I2C/"},{"name":"-uboot","slug":"uboot","link":"/tags/uboot/"},{"name":"-linux kernel","slug":"linux-kernel","link":"/tags/linux-kernel/"}],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"通信","slug":"通信","link":"/categories/%E9%80%9A%E4%BF%A1/"},{"name":"51单片机","slug":"51单片机","link":"/categories/51%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"linux内核","slug":"linux/linux内核","link":"/categories/linux/linux%E5%86%85%E6%A0%B8/"}]}