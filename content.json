{"pages":[{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"},{"title":"关于我","text":"这是我的个人博客，主要用来记录平时学习中的一些笔记，或是自己做的一些小项目的技术总结。","link":"/about/index.html"}],"posts":[{"title":"uboot常用命令","text":"linux命令行界面缓冲机制&emsp;&emsp;uboot的命令的读取采用的是行缓冲的机制。 行缓冲&emsp;&emsp;在命令行界面下，执行行缓冲，就是说，当你向界面输入命令的时候，输入的东西会先进入缓冲区，不会执行，但是当按下回车键之后，所有刚才输入的东西才会整个拿来分析执行。 无缓冲&emsp;&emsp;无缓冲就是每输入一个字符，系统就会分析处理该字符。 全缓冲&emsp;&emsp;全缓冲就是在输入字符后，直到缓冲区满，不然系统一直都不会去处理。 uboot指令的特点有些命令有简化的别名print==printenvset==setenv 有些命令会带参数不带：print/printenv可带不可带：help（不带参数信息不详细，带参数信息详细）必须带参数：set/setenv 命令中的特殊符号&lt;1&gt;uboot中一些特殊的符号有专门的意思，比如说单引号，目的是为了告诉uboot单引号里面的内容是一整块，不是分开的。&lt;2&gt;分号用来将两个命令隔开 有些命令是一个命令族。&emsp;&emsp;好多个命令都是用同一个开头，后面的部分不同，添加的参数参数和功能也不同，比如说movi命令。但是同一命令族的命令在功能上有很大的关联。比如movi命令族主要对（emmc，inand）进行操作。 uboot常用命令print/printenv官方解释如下 1234printenv - print values of all environment variablesprintenv name ... - print value of environment variable 'name' 由上可以看出，print/printenv有两种使用方式&lt;1&gt;print //用来打印出所有的环境变量。&lt;2&gt;print name //打印出特定的环境变量。 set/setenv官方解释如下 1234setenv name value ... - set environment variable 'name' to 'value ...'setenv name - delete environment variable 'name' 由上可以看出set/setenv有两种使用方式：&lt;1&gt;set name value //给名为name的环境变量赋值为value&lt;2&gt;set name //删除环境变量name save/savesave //将改变的环境变量值存储到flash中 题外话：每次系统上电之后，uboot都会将环境变量从flash中加载一份到ddr（内存）中，每次set的时候，都是对ddr中的环境变量进行改变，直到save指令后，ddr中的环境变量才会覆盖原来flash中的环境变量。 tftp题外话：配置完tftp可以通过网络从linux或者时windows下载镜像到DDR。uboot扮演客户端的角色，在win或是ubuntu中有tftp服务器，将要下载的东西放入服务器的下载目录中，就可以通过uboot中的命令实现下载。windows搭建tftp服务器：通过软件：tftpd32等等，使用简单。linux下搭建tftp服务器：网络上有很多经验，这里不做赘述。uboot中的tftp指令解释为： 12x210 # help tftp tftpboot [loadAddress] [[hostIPaddr:]bootfilename] 通过该命令可以将tftp配置的文件夹中的指定文件通过网络下载到指定位置。在使用该指令之前一定要在uboot中提前配置服务器的ip=serverip。注：uboot也支持nfs下载。","link":"/2020/05/06/uboot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"初识内核篇","text":"","link":"/2020/05/09/%E5%86%85%E6%A0%B8%E7%AF%872/"},{"title":"初识内核1","text":"关于驱动驱动为内核中硬件设备管理模块&emsp;&emsp;硬件设备的运行需要驱动代码，裸机开发中驱动代码需要专门写出来。但是在操作系统中，驱动代码嵌入到了内核里。由于每一种硬件设备需要一种驱动，所以说，内核的版本总是在更新之中。 驱动工作在内核态&emsp;&emsp;对于单核的cpu来讲，微观上cpu在某一刻只能运行一条指令。如果运行的代码属于内核，则为内核态；运行的代码属于应用程序，则为用户态。 驱动程运行时具有很高的权限&emsp;&emsp;由于驱动是运行在内核态的，所以她在运行时，具有最高的权限，也就是说可以任意访问读写内存的任何部分。所以说，驱动开发也伴随着很高的风险，一个不慎，就可能导致内核崩溃，出现安全漏洞。 关于应用程序应用程序是整个系统的最终目标&emsp;&emsp;无论是硬件还是内核，最终的目的就是为用户提供使用功能，而这些功能都是由应用程序来提供的。所以说，应用程序是整个操作系统的最终目标。 应用程序不属于内核，而是在内核之上应用程序工作在用户态，是受到限制的。应用程序出现问题一般不会导致内核崩溃。应用程序通过内核定义的API来调用内核工作。关于根文件系统&emsp;&emsp; 根文件系统为操作系统启动提供了很多东西：根目录，进程1。 根文件系统提供根目录根文件系统提供根目录进程1存放在根文件系统中内核启动最后会装在根文件系统","link":"/2020/05/09/%E5%86%85%E6%A0%B8%E7%AF%871/"},{"title":"初识linux内核","text":"到底什么是操作系统？&emsp;&emsp;具象化来讲就是linux，windows，android，ucos等都属于操作系统。操作系统本质上是一个程序，由很多源文件构成，需要编译链接成操作系统程序（vmlinz，zimage）。主要功能是管理计算机硬件，给应用程序提供运行环境。 核心功能内存管理&emsp;&emsp;没有操作系统的话，就需要程序员自己管理内存，万一出现内存复用的情况，很容易造成代码冲突。但是有了操作系统之后，每一次内存的使用，都需要向操作系统申请注册，这样，就会保证内存一般不会冲突。 进程调度功能&emsp;&emsp;操作系统下支持多个应用程序同时运行。这是宏观上的并行和微观上的串行。 硬件设备的管理&emsp;&emsp;没有操作系统时，控制任何硬件都要自己写代码，有了操作系统之后，操作系统自会控制硬件，应用程序不需要考虑硬件的具体细节。操作系统的硬件设备管理模块就是驱动模块。 文件系统&emsp;&emsp;文件系统是管理存储设备的一种方式。存储设备是由很多个扇区组成，存储设备要以扇区为单位进行读写。没有一种管理机制的话，程序就要记住哪个扇区里面存了什么东西，显然这是不现实的。而文件系统像是一个书的目录，可以用来管理哪一部分扇区存储了啥。 扩展功能协议栈有用的应用程序包&emsp;&emsp; 应用程序本身不属于操作系统内核，而是可以通过功能需求 进行增减的。 内核和发行版的区别&emsp;&emsp;内核只负责实现操作系统的核心功能，比如：内存管理，进度调控等等等等，应用程序并不包括在内。当一个操作系统基于内核，又包含了许多应用程序包等等面向使用者的接口，就可以称之为操作系统。由于不同产家根据不同的需求基于内核开发出各种内核的操作系统，称之为发行版。 内核只有一个linux内核网址 发行版很多ubuntu，redhat，centos等等。","link":"/2020/05/07/%E5%88%9D%E8%AF%86linux%E5%86%85%E6%A0%B8/"},{"title":"初识uboot","text":"本文学习自朱有鹏老师嵌入式课程，在此标注 起因&emsp;&emsp;以前学习过一些简单得linux系统移植，发现学的太浅了，脱离了开发板就完全应用不起来，所以现在打算深入得学习一下，力求达到无论是给我什么平台，就给他一顿修改代码，编译下载运行得操作系统跑起来。所以现在打算现从uboot入手开始学习。本文旨在对uboot做一个大概的描述。 臆想&emsp;&emsp;linux kernel刚开始是躺在flash中的，系统上电后不能直接运行起来（体大难移）。所以就需要一段程序来帮他将一切东西都打点好，比如将内存初始化，然后将kernel丢到内存中，然后kernel挂着根文件才能运行起来。那么，仅仅从主要功能上来讲，好像这一段程序只需要初始化一些内存，然后再讲kernel加载到内存就行了。实则非也，由于kernel的启动是不唯一的，也就是说给kernel在启动之前赋予不同的参数，那么它启动 结束之后就是不同的样子，还有就是要判断启动的过程是不是出错了？哪里出错了？肯定得将之表现出来以供人参考，故而需要串口等监视工具，所以还需要初始化串口驱动等等等等。这段功能强大的 程序，都快比的上一个小的操作系统了，她也被称之为bootloader。那么uboot又是何许人也，uboot算是bootloader的一种，但是她是开源的，由于被许多人使用，故而被越来越完善，逐渐成为人们最常用的一种bootloader。 uboot主要功能1.可以上电直接启动：由于soc设计不同，uboot要对应得更改START.S来实现这一功能。2.能够内核启动并为其传参：可以在uboot中设置一定得参数，然后放在内存的特定位置，然后等到内核启动得时候，就回去这些特定得位置解析这些参数，从而按照设定去启动。3.提供系统部署能力：人要能借助uboot完成整个系统（uboot，kernel，rootfs）在flash上的烧录下载工作。4.具有一定得硬件驱动能力：比如inand，串口，lcd等等，根据不同得情景要能够实现soc级和板级一些硬件得驱动能力。5.生命周期：uboot是裸机程序。一旦开始就会单纯运行uboot不能同时其他程序。一旦uboot结束运行，就没法再回到uboot。uboot启动内核之后就废了，想要再回到uboot只能重启。","link":"/2020/05/06/%E5%88%9D%E8%AF%86uboot/"},{"title":"记一次51汇编作业","text":"题目&emsp;&emsp;试设计一个n字节的无符号十进制数加法子程序， 其功能为将 R0和R1指出的内部RAM中两个n字节压缩BCD码无符号十进制整数相加，结果存放于被加数单元中。Ｒ0、 Ｒ1分别指向被加数和加数的低位字节， 字节数ｎ存于R2。运算结果：Ｒ0指向和的低位字节，CY为进位位。 分析子程序流程分析如下： 代码1234567891011121314151617181920212223242526272829 ORG 0000H SJMP MAIN ORG 0030H //初始化MAIN: MOV 40H,#72H MOV 41H,#33H MOV 60H,#33H MOV 61H,#44H //赋值 LCALL SUN SJMP WAIT SUN: MOV R0,#40H //求和子程序 MOV R1,#60H MOV R2,#2 MOV A,R2LOOP: JNZ FSUN SJMP ENDDFSUN: MOV A,@R0 ADDC A,@R1 DA A MOV @R0,A INC R0 INC R1 DEC R2 MOV A,R2 SJMP LOOP ENDD: RETWAIT: SJMP WAITEND 测试结果如下","link":"/2020/05/10/%E8%AE%B0%E4%B8%80%E6%AC%A151%E6%B1%87%E7%BC%96%E4%BD%9C%E4%B8%9A/"},{"title":"浅谈I2C","text":"原理&emsp;&emsp;I2C是一种工作在低速，短距离情况下用来传输数据的通信接口。她总共就只有两根线，一根为SCK(serial clock串行时钟线)，一根为SDA(serial data串行数据线)。由此不难看出，她是一种串行的，同步的通信方式。至于信号传输的方向，这里着重说一下。对于通信双方，有主（master）从（slave）之分，在一个确定的通信环境下面，一个master可以对应多个slave（在通信环境确定的情况下，master和slave的角色一般是确定的，不太容易更改），从而实现分时分对象的控制。那么问题来了，那么多的slave，master是如何辨别哪个是哪个呢，I2C的解决方案是通过地址来区分，一般情况下，每个slave都有一个7bit的地址，其中高四位是器件类型，由生产方来决定，低四位有硬件逻辑来编程（也就是说当硬件电路确定了之后，那么slave的地址也就确定了）。然后，通信双方就可以按照规定好的协议开始愉快的交流了。 I2C通信协议&emsp;&emsp; 话不多说，直接上图 &emsp;&emsp; 当master想要给slave发送信息时（write mode），通信开始后，先给SDA发送1byte的数据，这一段数据为：高7位slave的地址+0。然后等待对应的slave发送一个应答信号（ACK），当master收到ACK后，就给slave发送1byte的数据，然后slave收到信息了，就再给master发送一个ACK，至此，一个通信周期结束。&emsp;&emsp; 当slave要给master发送数据时（read mode），通信开始后，master先给SDA发送1byte的数据，数据为：高7位的slave地址+1（用1和0来区别到底是都还是写）。然后slave先ACK，然后紧接着就发送过来1byte的数据，发送完之后，等待master的ACK，之后一个通信周期结束。&emsp;&emsp; 各位看官看到这里，是不是对I2C通信协议有了大概的了解呢，但是心里肯定还是有不少疑惑，比如说，数据全部都是通过电平信号来传输的，那么我怎么知道什么情况下通信开始？什么情况下通信结束？是么样的信号算是应答信号？各种信号在时间上又如何调节呢？莫急，我们再上图 &emsp;&emsp; 这前面这两张图片时三星某soc的datasheet上抠下来的，这里做个说明 &emsp;&emsp; 言归正传，大家看到这张图片是不是有点恍恍然的感觉呢，没错，这张时序图可以将我们之前的疑惑一一解除。首先，我们是否还记得最前面说过得I2C是一个同步通信得方式，那么，如何把握节奏就不言而喻了，就是通过时钟信号来调控。当某一个时刻，SCK为高电平时，SDA上出现了一个下降沿，那么意味着，通信开始，要开始搞事情了。然后master二话不说，先丢1byte得数据过去，告诉众slave，该谁了，该干啥了。然后slave如果没挂（通信时有时候从机会莫名奇妙得由于各种奇葩得原因挂掉）的话，就会站出来说一声，在呢（也就是发送一个ACK给master）。那么具体如何实现ACK呢？I2C总线上的数据时1byte1byte传输的，每传输1byte的数据需要8个时钟周期，当1byte数据传输完毕之后，总线会被控制为高电平(总线释放)，当第九个脉冲之前，应答方将之拉低成了低电平，而且在第九个时钟高电平的时候保持低电平则称之为ACK；要是没有反应，继续保持为高电平，则称之为NACK。然后就是数据传输，又是一个字节，然后ACK，之后完事收工，总线在SCL期间恢复到高电平，即完成一个上升沿，一切的一切恢复如初，好像什么都没有发生过。 &emsp;&emsp; 至此，对I2C算是有了一个粗浅的了解。如文章中有不足之处，还望指正。","link":"/2020/05/02/%E6%B5%85%E8%B0%88I2C/"},{"title":"windows下fastboot刷机","text":"本文旨在介绍如何在windows环境下通过fastboot实现简单的刷机。 何为fastboot&emsp;&emsp;fastboot是windows下的一款软件，亦是uboot中的一句命令。fastboot指令在uboot中介绍如下： 12345x210 # help fastbootfastboot [inactive timeout] - Run as a fastboot usb device. - The optional inactive timeout is the decimal seconds before - the normal console resumes 目的&emsp;&emsp;1.环境：win10&emsp;&emsp;2.刷机对象：S5PV210(ARM Cortex -A8)&emsp;&emsp;3.linux+QT4.8 步骤硬件准备&emsp;&emsp;1.连接usb线（fastboot数据传输）&emsp;&emsp;2.连接usb转串口线（串口监视下载过程） 软件准备&emsp;&emsp;1.在电脑中安装fastboot驱动&emsp;&emsp;2.将预安装系统的bootloader，系统镜像，rootfs放在fastboot安装目录下（最好是将每个操作系统的预安装文件放在fastboot目录下的一个单独的目录下）。 开始安装1.在uboot中运行fastboot，现象如下： 123456789x210 # fastboot[Partition table on MoviNAND]ptn 0 name='bootloader' start=0x0 len=N/A (use hard-coded info. (cmd: movi))ptn 1 name='kernel' start=N/A len=N/A (use hard-coded info. (cmd: movi))ptn 2 name='ramdisk' start=N/A len=0x300000(~3072KB) (use hard-coded info. (cmd: movi))ptn 3 name='config' start=0xB11E00 len=0x1024BC00(~264495KB)ptn 4 name='system' start=0x10D5DA00 len=0x1024BC00(~264495KB)ptn 5 name='cache' start=0x20FA9600 len=0x6751800(~105798KB)ptn 6 name='userdata' start=0x276FAE00 len=0xC3CC2A00(~3207946KB) 连接成功的标志是win10在cmd中切到fastboot安装目录下可见输入 fastboot devices 可见设备. 12D:\\fastboot install\\fastboot&gt;fastboot devicesSMDKC110-01 fastboot 到现在为止，说明嵌入式开发板已经和pc机连接起来了，可以开始进行数据传输了。2.烧录ubootcmd切入到fastboot目录下输入fastboot flash bootloader linux+QT4.8\\uboot.bin。cmd中显示如下 123D:\\fastboot install\\fastboot&gt;fastboot flash bootloader linux+QT4.8\\uboot.binsending 'bootloader' (384 KB)... OKAYwriting 'bootloader'... OKAY 串口监视器中（嵌入式设备）显示如下： 123456789Received 17 bytes: download:00060000Starting download of 393216 bytesdownloading of 393216 bytes finishedReceived 16 bytes: flash:bootloaderflashing 'bootloader'Writing BL1 to sector 1 (16 sectors).. checksum : 0xed75ewriting bootloader.. 49, 1024MMC write: dev 说明uboot.bin烧录成功。注意：这里是在往bootloader分区烧录uboot，我的uboot.bin是放在fastboot目录下的linux+QT4.8文件夹中，故而输入如上，这里输入的是相对地址。 3.重启嵌入式设备，进入新下载的uboot中输入fdisk -c 0 ,意为格式化inand，结果如下： 12345678x210 # fdisk -c 0fdisk is completedpartion # size(MB) block start # block count partition_Id 1 258 22671 528990 0x83 2 258 551661 528990 0x83 3 103 1080651 211596 0x83 4 3132 1292247 6415893 0x83 4.重新进入fastboot模式。开始烧录kernel。cmd中如下： D:\\fastboot install\\fastboot&gt;fastboot flash kernel linux+QT4.8\\zImage-qt sending 'kernel' (3566 KB)... OKAY writing 'kernel'... OKAY 串口监视器结果如下： downloading of 3651584 bytes finished Received 12 bytes: flash:kernel flashing 'kernel' writing kernel.. 1073, 8192 MMC write: dev # 0, block # 1073, count 8192 ... 8192 blocks written: OK completed partition 'kernel' flashed kernel烧录完成。 5.开始烧录rootfs烧录时间较慢。cmd中： D:\\fastboot install\\fastboot&gt;fastboot flash system linux+QT4.8\\rootfs_qt4.ext3 sending 'system' (262144 KB)... OKAY writing 'system'... OKAY 串口监视器中： Received 17 bytes: download:10000000 Starting download of 268435456 bytes ................................................................................ ................................................................................ ................................................................................ ............... downloading of 268435456 bytes finished Received 12 bytes: flash:system flashing 'system' MMC write: dev # 0, block # 551661, count 528990 ... 528990 blocks written: OK partition 'system' flashed rootfs下载结束。ok，大功告成。赶紧reset感受一下吧。 本文大概介绍了一下使用fastboot工具来刷机时的大概步骤，有错误缺漏之处欢迎大家补充。","link":"/2020/05/11/fastboot%E5%88%B7%E6%9C%BA/"},{"title":"STM32之I/O配置","text":"&emsp;&emsp;这一场是32局，先对STM32的八种I/O模式做见到那介绍 I/O口模式输出&lt;1&gt;推挽输出：0为低电平；1为高电平。较常用，无双向I/O口功能。&lt;2&gt;开漏输出：0为低电平；1为悬空状态，拉高为高，拉低为低。可以读取pin脚电平信号，有双向I/O口功能。&lt;3&gt;复用推挽输出：内部外设功能，具体复用功能得参考datasheet。&lt;4&gt;复用开漏输出：内部外设功能，具体复用功能得参考datasheet。 输入&lt;1&gt;带上拉输入：未输入时内部上拉为高电平。&lt;2&gt;带下拉输入：未输入时内部下拉为低电平。&lt;3&gt;浮空输入：未输入时内部电平不确定。可用于检测key。&lt;4&gt;模拟输入：应用于ADC的模拟量输入口。","link":"/2020/05/17/STM32%E4%B9%8BI-O%E9%85%8D%E7%BD%AE/"},{"title":"linux kernel简单解析1","text":"文件分析1.’.gitignore’git用来管理内核版本2.’.mailmap’一些相关领域开发者的联系方式3.’COPYING’版权相关4.’COPYING.txt’版权相关5.’CREDITS’感谢文件6.’initrd.img.cpio’传参设备树7.’Kbuild’kernel build ，内核编译，就是用来管理内核编译的。8.’MAINTAINEERS’维护人员9.’Makefile’linux内核的总Makefile，管理内核。10.’mk’九鼎自己添加的开发qt有关的文件。不是linux kernel本身的东西。作用为用这个文件整体来管理kernel目录的配置和编译。有点类似于uboot中的cp.sh11.’README’简单的说明文件12.’REPORTING-BUGS’BUGS 上报 初识linux kernel配置体系1.庞大且可配置性非常高，配置比较复杂，需要一套专门的机制来解决。 文件夹：1.archarchitecture的缩写。arm，x86等架构相关。2.block块。表示块设备，以块为单位来访问的设备。块设备：多个字节组成的整体为单位进行访问的设备。比如说sd卡，inand，nand，硬盘等都是块设备。block目录下放的就是有关块设备管理的代码。3.crypto加密。目录下放了一些常见的加密算法的c语言代码。比如crc32,md5,sha1等。4.documentation文档。6.drivers驱动目录。里面放驱动代码。7.firmware固件：固化到ic里面运行的软件。像是S5PV210的IROM代码。8.fsfile system 文件系统。里面列出了linux支持的各种文件系统。9.include头文件目录。公共头文件目录，各种cpu arch共用的头文件。每种cpu架构特有的文件夹在arch中。10.init初始化。kernel启动时初始化的代码。初始化的时kernel本身。11.ipcinter process communication进程间通信相关代码12.kernel文件夹下放的是内核本身的一些代码13.lib库。都是一些公用的有用的库函数。在内核中不能用c语言中库函数。这里的库函数是用来替代那些表中库函数的。比如：内核中将字符串转化成数字用atoi，但是内核中只能用lib下的atoi；内核中打印函数用printk。 14.mmmemory management 内存管理。15.net网络相关的代码。比如tcp/ip协议都此16.scripts脚本。辅助kernel进行配置编译。17.security安全相关18.sound音频相关19.tools一些有用工具20.user和启动有关。21.virt。内核虚拟机相关的。","link":"/2020/05/14/linux-kernel%E7%AE%80%E5%8D%95%E8%A7%A3%E6%9E%901/"},{"title":"linux常用命令","text":"cp1.name2.synopsis3.description4.author5.reporting bugs6.copyright7.see alsoNAME cp - copy files and directories SYNOPSIS cp [OPTION]… [-T] SOURCE DEST cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… DESCRIPTION Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY. Mandatory arguments to long options are mandatory for short options too. -a, --archive same as -dR --preserve=all --attributes-only don&apos;t copy the file data, just the attributes --backup[=CONTROL] make a backup of each existing destination file -b like --backup but does not accept an argument","link":"/2020/05/22/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"常见I/O控制方式","text":"&emsp;&emsp; cpu和外设之间通过I/O口实现数据交互。为了更好的协调cpu和外设之间的数据传输，cpu需要对外设采取一定的控制方式。常见的控制方式有查询控制方式，中断控制方式和DMA控制方式。 查询控制方式原理&emsp;&emsp;1.数据从外设到cpu时，cpu先要查询外设的状态标志位，判断外设是否准备好了数据，若是准备好了数据，则cpu读取数据。否则，循环查询状态标志位。2.数据从cpu到外设时，cpu先要查询外设是否准备好了接受数据，若准备好了，则cpu将数据放到总线供外设读取，若是外设没有准备好，则cpu循环查询标志位。 优点1.由于整个数据传输过程中cpu都处于主动位置，整个通信的节奏都由cpu把控，所以是一种天然的同步控制机制。传输数据可靠。2.逻辑简单，软硬件设计皆不复杂。 缺点1.cpu必须不断的查询I/0的状态标志位，才能保证不会有数据丢失。这样的机制里面cpu将大部分的时间用在了等待外设上面，实际上为外设传输数据的时间很少，软件时间等成本很高。2.一般情况下，cpu不可能只进行I/0口的数据传输，还要进行一些运算等其他任务，使用这种方法时，只能将这些代码写入循环体之内，这样话，其他的任务越多，cpu每次循环的周期势必越长，故而控制系统的实时性必将大打折扣。 应用&emsp;&emsp; 乍一看好像这种控制方法很low，但是老话说“没有最好的，只有最适合的。”具体这种方法的好坏得看实际情况。比如说某些特定场景下cpu的任务量不大，控制的I/O口也不是很多，对实时性要求也不是很高，这种情况下就可以采用查询控制方式。 个人见解&emsp;&emsp; 简单有效才是王道，笔者在以前做单片机智能小车的时候，小伙伴们清一色的查询控制方式，输入也查询，输出也查询，效果很多时候也很不错。关于外设状态标志位的检测，本人觉得也要分外设的种类，一些特定场合的较高级的外设才需要随时对标志位进行检测，许多简单的外设像红外传感器等等，都是直接进行数据输入，管你准备没准备好，直接上手薅数据。这时候想起了香农定理~ 中断控制方式原理&emsp;&emsp; 这种控制方式下，cpu正常运行其他的程序，当外设需要与cpu交流时，会向cpu发出中断请求，cpu接收到中断请求后，就转去执行中断程序，当中断程序处理完成之后，就返回继续运行其他程序。 优点1.省去了查询外设状态标志位和等待外设等待就绪所花费的时间，大大的提高了cpu工作效率。2.由于外设和cpu双线工作，满足了系统实时性的要求。 缺点1.每一个中断功能的产生，都需要一堆的软硬件进行支持。包括为每个I/O设备分配中断请求号，编写中断服务程序，设计中断管理机制等等。2.每次cpu执行中断服务程序的时候都需要保护断点，转去执行中断程序，恢复断点，返回被中断的程序继续进行等。每执行一次中断都需要cpu额外做很多工作，对于数据传输量很大的系统，则系统的工作效率相对较低。3.中断程序的编写相对较难，很容易造成错误，尤其是用高级语言的时候。 个人见解&emsp;&emsp; 中断资源的丰富与否是判断cpu性能的重要指标，许多对于外设的控制都离不开中断，比如UART等。 DMA控制方式原理数据传输中的战斗鸡，在soc中可直接对内存控制，妥妥的走后门。当外设向DMA控制器发送数据信号后，DMA直接向cpu申请总线使用权，当cpu将大权交给DMA后，DMA直接安排数据入驻内存。 个人见解&emsp;&emsp; 平常接触较少，但早听闻大名，期待和之交流。","link":"/2020/05/23/%E5%B8%B8%E8%A7%81I-O%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F/"}],"tags":[{"name":"uboot命令","slug":"uboot命令","link":"/tags/uboot%E5%91%BD%E4%BB%A4/"},{"name":"内核的模块化","slug":"内核的模块化","link":"/tags/%E5%86%85%E6%A0%B8%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/"},{"name":"linux kernel","slug":"linux-kernel","link":"/tags/linux-kernel/"},{"name":"uboot","slug":"uboot","link":"/tags/uboot/"},{"name":"I2C","slug":"I2C","link":"/tags/I2C/"},{"name":"fastboot","slug":"fastboot","link":"/tags/fastboot/"}],"categories":[{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"内核","slug":"linux/内核","link":"/categories/linux/%E5%86%85%E6%A0%B8/"},{"name":"uboot","slug":"linux/uboot","link":"/categories/linux/uboot/"},{"name":"嵌入式","slug":"嵌入式","link":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"},{"name":"通信","slug":"通信","link":"/categories/%E9%80%9A%E4%BF%A1/"},{"name":"刷机","slug":"linux/刷机","link":"/categories/linux/%E5%88%B7%E6%9C%BA/"},{"name":"51","slug":"嵌入式/51","link":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/51/"},{"name":"I2C","slug":"通信/I2C","link":"/categories/%E9%80%9A%E4%BF%A1/I2C/"},{"name":"STM32","slug":"嵌入式/STM32","link":"/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/STM32/"},{"name":"微型计算机控制","slug":"微型计算机控制","link":"/categories/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8E%A7%E5%88%B6/"}]}