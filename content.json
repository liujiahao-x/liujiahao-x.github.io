{"pages":[{"title":"关于我","text":"这是我的个人博客，主要用来记录平时学习中的一些笔记，或是自己做的一些小项目的技术总结。","link":"/about/index.html"},{"title":"","text":"","link":"/categories/index.html"},{"title":"","text":"","link":"/tags/index.html"}],"posts":[{"title":"uboot常用命令","text":"linux命令行界面缓冲机制&emsp;&emsp;uboot种命令的读取采用的是行缓冲的机制。 1.行缓冲&emsp;&emsp;在命令行界面下，就会执行行缓冲，也就是说，当你向界面输入命令的时候，输入的东西会先进入缓冲区，不会执行，但是当按下回车键之后，所有刚才输入的东西才会整他拿来分析执行。 2.无缓冲&emsp;&emsp;无缓冲就是每输入一个字符，系统就会分析出来该字符。 3.全缓冲&emsp;&emsp;全缓冲就是在输入字符后，直到缓冲区满，不然系统一直都不会去处理。 uboot指令的特点特点1.有些命令有简化的别名print==printenvset==setenv 2.有些命令会带参数不带：print/printenv可带不可带：help（不带参数信息不详细，带参数信息详细）必须带参数：set/setenv 3.命令中的特殊符号&lt;1&gt;uboot中一些特殊的符号有专门的意思，比如说单引号，目的是为了告诉uboot单引号里面的内容是一整块，不是分开的。&lt;2&gt;分号用来将两个命令隔开 4.有些命令是一个命令族。&emsp;&emsp;好多个命令都是用同一个开头，后面的部分不同，添加的参数参数和功能也不同，比如说movi命令。但是同一命令族的命令在功能上有很大的关联。比如movi命令族主要对（emmc，inand）进行操作。 uboot常用命令1.print/printevn官方解释如下 1234printenv - print values of all environment variablesprintenv name ... - print value of environment variable 'name' 由上可以看出，print/printevn有两种使用方式&lt;1&gt;print: 用来打印出所有的环境变量。&lt;2&gt;print name：打印出特定的环境变量。","link":"/2020/05/06/uboot%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"title":"初识uboot","text":"本文学习自朱有鹏老师嵌入式课程，在此标注 起因&emsp;&emsp;以前学习过一些简单得linux系统移植，发现学的太浅了，脱离了开发板就完全应用不起来，所以现在打算深入得学习一下，力求达到无论是给我什么平台，就给他一顿修改代码，编译下载运行得操作系统跑起来。所以现在打算现从uboot入手开始学习。本文旨在对uboot做一个大概的描述。 臆想&emsp;&emsp;linux kernel刚开始是躺在flash中的，系统上电后不能直接运行起来（体大难移）。所以就需要一段程序来帮他将一切东西都打点好，比如将内存初始化，然后将kernel丢到内存中，然后kernel挂着根文件才能运行起来。那么，仅仅从主要功能上来讲，好像这一段程序只需要初始化一些内存，然后再讲kernel加载到内存就行了。实则非也，由于kernel的启动是不唯一的，也就是说给kernel在启动之前赋予不同的参数，那么它启动 结束之后就是不同的样子，还有就是要判断启动的过程是不是出错了？哪里出错了？肯定得将之表现出来以供人参考，故而需要串口等监视工具，所以还需要初始化串口驱动等等等等。这段功能强大的 程序，都快比的上一个小的操作系统了，她也被称之为bootloader。那么uboot又是何许人也，uboot算是bootloader的一种，但是她是开源的，由于被许多人使用，故而被越来越完善，逐渐成为人们最常用的一种bootloader。 uboot主要功能1.可以上电直接启动：由于soc设计不同，uboot要对应得更改START.S来实现这一功能。2.能够内核启动并为其传参：可以在uboot中设置一定得参数，然后放在内存的特定位置，然后等到内核启动得时候，就回去这些特定得位置解析这些参数，从而按照设定去启动。3.提供系统部署能力：人要能借助uboot完成整个系统（uboot，kernel，rootfs）在flash上的烧录下载工作。4.具有一定得硬件驱动能力：比如inand，串口，lcd等等，根据不同得情景要能够实现soc级和板级一些硬件得驱动能力。5.生命周期：uboot是裸机程序。一旦开始就会单纯运行uboot不能同时其他程序。一旦uboot结束运行，就没法再回到uboot。uboot启动内核之后就废了，想要再回到uboot只能重启。","link":"/2020/05/06/%E5%88%9D%E8%AF%86uboot/"},{"title":"浅谈I2C","text":"原理&emsp;&emsp;I2C是一种工作在低速，短距离情况下用来传输数据的通信接口。她总共就只有两根线，一根为SCK(serial clock串行时钟线)，一根为SDA(serial data串行数据线)。由此不难看出，她是一种串行的，同步的通信方式。至于信号传输的方向，这里着重说一下。对于通信双方，有主（master）从（slave）之分，在一个确定的通信环境下面，一个master可以对应多个slave（在通信环境确定的情况下，master和slave的角色一般是确定的，不太容易更改），从而实现分时分对象的控制。那么问题来了，那么多的slave，master是如何辨别哪个是哪个呢，I2C的解决方案是通过地址来区分，一般情况下，每个slave都有一个7bit的地址，其中高四位是器件类型，由生产方来决定，低四位有硬件逻辑来编程（也就是说当硬件电路确定了之后，那么slave的地址也就确定了）。然后，通信双方就可以按照规定好的协议开始愉快的交流了。 I2C通信协议&emsp;&emsp; 话不多说，直接上图 &emsp;&emsp; 当master想要给slave发送信息时（write mode），通信开始后，先给SDA发送1byte的数据，这一段数据为：高7位slave的地址+0。然后等待对应的slave发送一个应答信号（ACK），当master收到ACK后，就给slave发送1byte的数据，然后slave收到信息了，就再给master发送一个ACK，至此，一个通信周期结束。&emsp;&emsp; 当slave要给master发送数据时（read mode），通信开始后，master先给SDA发送1byte的数据，数据为：高7位的slave地址+1（用1和0来区别到底是都还是写）。然后slave先ACK，然后紧接着就发送过来1byte的数据，发送完之后，等待master的ACK，之后一个通信周期结束。&emsp;&emsp; 各位看官看到这里，是不是对I2C通信协议有了大概的了解呢，但是心里肯定还是有不少疑惑，比如说，数据全部都是通过电平信号来传输的，那么我怎么知道什么情况下通信开始？什么情况下通信结束？是么样的信号算是应答信号？各种信号在时间上又如何调节呢？莫急，我们再上图 &emsp;&emsp; 这前面这两张图片时三星某soc的datasheet上抠下来的，这里做个说明 &emsp;&emsp; 言归正传，大家看到这张图片是不是有点恍恍然的感觉呢，没错，这张时序图可以将我们之前的疑惑一一解除。首先，我们是否还记得最前面说过得I2C是一个同步通信得方式，那么，如何把握节奏就不言而喻了，就是通过时钟信号来调控。当某一个时刻，SCK为高电平时，SDA上出现了一个下降沿，那么意味着，通信开始，要开始搞事情了。然后master二话不说，先丢1byte得数据过去，告诉众slave，该谁了，该干啥了。然后slave如果没挂（通信时有时候从机会莫名奇妙得由于各种奇葩得原因挂掉）的话，就会站出来说一声，在呢（也就是发送一个ACK给master）。那么具体如何实现ACK呢？I2C总线上的数据时1byte1byte传输的，每传输1byte的数据需要8个时钟周期，当1byte数据传输完毕之后，总线会被控制为高电平(总线释放)，当第九个脉冲之前，应答方将之拉低成了低电平，而且在第九个时钟高电平的时候保持低电平则称之为ACK；要是没有反应，继续保持为高电平，则称之为NACK。然后就是数据传输，又是一个字节，然后ACK，之后完事收工，总线在SCL期间恢复到高电平，即完成一个上升沿，一切的一切恢复如初，好像什么都没有发生过。 &emsp;&emsp; 至此，对I2C算是有了一个粗浅的了解。如文章中有不足之处，还望指正。","link":"/2020/05/02/%E6%B5%85%E8%B0%88I2C/"}],"tags":[{"name":"-uboot","slug":"uboot","link":"/tags/uboot/"},{"name":"-I2C","slug":"I2C","link":"/tags/I2C/"}],"categories":[{"name":"uboot","slug":"uboot","link":"/categories/uboot/"},{"name":"通信","slug":"通信","link":"/categories/%E9%80%9A%E4%BF%A1/"}]}